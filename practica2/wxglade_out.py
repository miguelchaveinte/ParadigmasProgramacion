#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.5 on Sat Apr 18 15:40:29 2020
#
import wx.lib.agw.shapedbutton as SB
import wx
import random
import copy

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade


diccionario_2048 = {"A": "3-1.png" ,"B": "3-2.png", "C": "3-3.png", "D": "3-4.png", "E": "3-5.png", "F": "3-6.png", "G": "3-7.png", "H": "3-8.png", "I": "3-9.png",
                    "J": "3-10.png",
                    "K": "3-11.png", ".":"Vacio.png", "*": "Bloque.png"}
diccionario_1024 = {"A": "2-1.png" ,"B": "2-2.png", "C": "2-3.png", "D": "2-4.png", "E": "2-5.png", "F": "2-6.png", "G": "2-7.png", "H": "2-8.png", "I": "2-9.png",
                    "J": "2-10.png",
                    "K": "2-11.png", ".":"Vacio.png", "*": "Bloque.png"}
diccionario_abc = {"A": "0-1.png" ,"B": "0-2.png", "C": "0-3.png", "D": "0-4.png", "E": "0-5.png", "F": "0-6.png", "G": "0-7.png", "H": "0-8.png", "I": "0-9.png",
                    "J": "0-10.png",
                    "K": "0-11.png", ".":"Vacio.png", "*": "Bloque.png"}
diccionario_nivel = {"A": "1-1.png" ,"B": "1-2.png", "C": "1-3.png", "D": "1-4.png", "E": "1-5.png", "F": "1-6.png", "G": "1-7.png", "H": "1-8.png", "I": "1-9.png",
                    "J": "1-10.png",
                    "K": "1-11.png", ".":"Vacio.png", "*": "Bloque.png"}



class MiVentana(wx.Frame):
    matriz = []
    def __init__(self, *args, **kwds):
        # begin wxGlade: MiVentana.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((700, 507))
        self.newsheet_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("newsheet.ico", wx.BITMAP_TYPE_ICO))
        self.open_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("abrir.ico", wx.BITMAP_TYPE_ICO))
        self.save_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("save.ico", wx.BITMAP_TYPE_ICO))
        self.bitmap_button_undo = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("undo.ico", wx.BITMAP_TYPE_ICO))
        self.radio_btn_2048 = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_abc = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_nivel = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_1024 = wx.RadioButton(self, wx.ID_ANY, "")
        self.matrix = wx.Panel(self, wx.ID_ANY)

        #AQUI SE CREA LA PRIMERA MATRIZ
        self.size = 4
        z = 0
        l = 0
        for i in range(self.size):
            self.matriz.append([" "] * self.size)
        while z < 2:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if self.matriz[rand_r][rand_c] == " ":
                self.matriz[rand_r][rand_c] = diccionario_2048["*"]
                z = z +1
        while l < 2:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if self.matriz[rand_r][rand_c] != diccionario_2048["*"]:
                self.matriz[rand_r][rand_c] = diccionario_2048["A"]
                l = l + 1
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] == " ":
                    self.matriz[r][c] = diccionario_2048["."]

        self.diccionario_antiguo = diccionario_2048

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnBtnSave, self.save_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnNewMatrix, self.newsheet_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnUndo, self.bitmap_button_undo)
        self.Bind(wx.EVT_BUTTON, self.OnBtnOpen, self.open_button)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic2048, self.radio_btn_2048)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic1024, self.radio_btn_1024)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicNivel, self.radio_btn_nivel)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicABC, self.radio_btn_abc)

        # end wxGlade

    def Matrix(self):
        for i in range(3):
            self.matriz.append([" "] * 3)
        while i < 2:
            rand_r = random.randint(0, 3 - 1)
            rand_c = random.randint(0, 3 - 1)
            if self.matriz[rand_r][rand_c] == " ":
                self.matriz[rand_r][rand_c] = diccionario_2048["*"]
        while i < 2:
            rand_r = random.randint(0, 3 - 1)
            rand_c = random.randint(0, 3 - 1)
            if self.matriz[rand_r][rand_c] != diccionario_2048["*"]:
                self.matriz[rand_r][rand_c] = diccionario_2048["A"]
        for i in range(3):
            for j in range(3):
                if self.matriz[i][j] == " ":
                    self.matriz[i][j] = diccionario_2048["."]
        return self.matriz


    def __set_properties(self):
        # begin wxGlade: MiVentana.__set_properties
        self.SetTitle("frame")
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetSize(self.newsheet_button.GetBestSize())

        self.open_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.open_button.SetSize(self.open_button.GetBestSize())
        self.save_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.save_button.SetSize(self.save_button.GetBestSize())

        self.bitmap_button_undo.SetMinSize((48, 48))
        self.bitmap_button_undo.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.radio_btn_nivel.SetFont(wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Segoe UI"))
        self.matrix.SetMinSize((370, 300))
        self.matrix.SetBackgroundColour(wx.Colour("black"))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MiVentana.__do_layout
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        sizer_1 = wx.GridSizer(0, 0, 0, 0)

        sizer_4 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, "MODO"), wx.HORIZONTAL)
        grid_sizer_5 = wx.GridSizer(4, 2, 0, 0)
        grid_sizer_3 = wx.GridSizer(2, 1, 0, 0)
        grid_sizer_4 = wx.GridSizer(1, 3, 0, 0)
        grid_sizer_4.Add(self.newsheet_button, 0, wx.EXPAND | wx.LEFT | wx.TOP, 10)
        grid_sizer_4.Add(self.open_button, 0, wx.EXPAND | wx.LEFT | wx.TOP, 10)
        grid_sizer_4.Add(self.save_button, 0, wx.EXPAND | wx.LEFT | wx.TOP, 10)
        grid_sizer_3.Add(grid_sizer_4, 1, wx.EXPAND, 0)
        grid_sizer_3.Add((0, 0), 0, 0, 0)
        grid_sizer_2.Add(grid_sizer_3, 1, wx.EXPAND, 0)
        grid_sizer_2.Add((0, 0), 0, 0, 0)
        grid_sizer_2.Add(self.bitmap_button_undo, 0, wx.ALIGN_CENTER | wx.BOTTOM | wx.LEFT, 53)
        label_2048 = wx.StaticText(self, wx.ID_ANY, "2048")
        label_2048.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_5.Add(label_2048, 0, wx.ALIGN_CENTER, 0)
        grid_sizer_5.Add(self.radio_btn_2048, 0, wx.ALIGN_CENTER, 0)
        label_abc = wx.StaticText(self, wx.ID_ANY, "ABC")
        label_abc.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_5.Add(label_abc, 0, wx.ALIGN_CENTER, 0)
        grid_sizer_5.Add(self.radio_btn_abc, 0, wx.ALIGN_CENTER, 0)
        label_nivel = wx.StaticText(self, wx.ID_ANY, "Nivel")
        label_nivel.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_5.Add(label_nivel, 0, wx.ALIGN_CENTER, 0)
        grid_sizer_5.Add(self.radio_btn_nivel, 0, wx.ALIGN_CENTER, 0)
        label_1024 = wx.StaticText(self, wx.ID_ANY, "1024")
        label_1024.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_5.Add(label_1024, 0, wx.ALIGN_CENTER, 0)
        grid_sizer_5.Add(self.radio_btn_1024, 0, wx.ALIGN_CENTER, 0)
        sizer_4.Add(grid_sizer_5, 1, wx.EXPAND, 0)
        grid_sizer_2.Add(sizer_4, 0, wx.EXPAND | wx.LEFT, 8)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)

        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)

        grid_sizer_2.Add((0, 0), 0, 0, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "AUTORES:\n@Abdu\n@Miguel")
        label_2.SetMinSize((112, 100))
        label_2.SetFont(wx.Font(16, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_2.Add(label_2, 0, wx.ALIGN_BOTTOM | wx.LEFT, 7)
        label_movs = wx.StaticText(self, wx.ID_ANY, "MOVIMIENTOS: ")
        label_movs.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_2.Add(label_movs, 0, wx.ALIGN_CENTER | wx.TOP, 18)
        label_puntos = wx.StaticText(self, wx.ID_ANY, "PUNTOS: ")
        label_puntos.SetFont(wx.Font(12, wx.FONTFAMILY_SCRIPT, wx.FONTSTYLE_ITALIC, wx.FONTWEIGHT_BOLD, 0, "Comic Sans MS"))
        grid_sizer_2.Add(label_puntos, 0, wx.ALIGN_CENTER_VERTICAL | wx.TOP, 18)
        sizer_3.Add(grid_sizer_2, 1, wx.EXPAND, 0)

        self.SetSizer(sizer_3)
        self.Layout()
        # end wxGlade
    def OnBtnNewMatrix(self, event):  # wxGlade: MyFrame.<event_handler
        pass
        """dlg = GetData(parent=self.panel)
        dlg.ShowModal()
        if dlg.result_name:
            self.log.AppendText("Name: " + dlg.result_name + "\n")
            self.log.AppendText("Surname: " + dlg.result_surname + "\n")
            self.log.AppendText("Nickname: " + dlg.result_nickname + "\n")
        else:
            self.log.AppendText("No Input found\n")
        dlg.Destroy()"""

    def OnBtnOpen(self, event):  # wxGlade: MyFrame.<event_handler>
        r = -1
        print("poner dialogo aqui, abrir, lectura y generacion de matriz")
        direccion = wx.FileDialog(self, "Cargar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                           style=wx.FD_OPEN )

        if direccion.ShowModal() == wx.ID_CANCEL:
            return
        partida = open(direccion.GetPath(), "r+")
        self.size = int(partida.readline())
        self.movimientos = int(partida.readline())
        self.puntos = int(partida.readline())

        for i in range(self.size):
            self.matriz.append([" "] * self.size)


        for position, line in enumerate(partida):

            r += 1

            for c in range(self.size):
                char = line[c]

                self.matriz[r][c] = diccionario_2048[char]

        partida.close()
        sizer_1 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        self.diccionario_antiguo = diccionario_2048
        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)

    def OnBtnSave(self, event):  # wxGlade: MyFrame.<event_handler>
        movimientos = 10
        puntos = 19
        fileDialog = wx.FileDialog(self, "Guardar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)

        if fileDialog.ShowModal() == wx.ID_CANCEL:
            return
        nombre_usr = fileDialog.GetPath()
        try:
            archivo =  open(nombre_usr, 'w+')
            archivo.write(str(self.size))
            archivo.write("\n")
            archivo.write(str(movimientos))
            archivo.write("\n")
            archivo.write(str(puntos))
            archivo.write("\n")
            for r in range(self.size):
                for c in range(self.size):

                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    archivo.write(clave[0])

                    if c == self.size - 1:
                        archivo.write("\n")

            archivo.close()
        except IOError:
            wx.LogError("No se puede guardar aqui: '%s'." % nombre_usr)

    def OnBtnUndo(self, event):  # wxGlade: MyFrame.<event_handler>
        print("guardar ultima matriz y en caso de pulsarlo, imprimir esta.")
        self.inp = "D"
        if self.inp == "S" or self.inp == "B" or self.inp == "I" or self.inp == "D":
            self.matriz_comparar = copy.deepcopy(self.matriz)  # copiamos la matriz antes de realizar el movimiento
            Matriz.eleccion(diccionario_nivel)  # llamamos a la funcion que nos realizara todo aquello referente al movimiento
	    print(matriz)
            igual = Matriz.comparar(self.matriz, self.matriz_comparar,
                                self.size)  # llamamos a la funcion comparar que nos dira si la matriz anterior y la actual son iguales
            if igual:  # si son iguales restamos un movimientos ya que previamente se le habia sumado uno cuando la matriz es igual
                pass #movimientos = movimientos - 1  # cuando la matriz resultante es igual y por tanto no introducimos un nuevo valor tampoco
            else:
                pass
    def OnBtnDic2048(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a 2048")
        diccionario_nuevo = diccionario_2048

        self.cambiar_diccionario(diccionario_nuevo)
        sizer_1 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        self.diccionario_antiguo = diccionario_2048
        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)

    def OnBtnDic1024(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a 1024")
        diccionario_nuevo = diccionario_1024

        self.cambiar_diccionario(diccionario_nuevo)
        sizer_1 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        self.diccionario_antiguo = diccionario_1024
        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)

    def OnBtnDicNivel(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a nivel")

        diccionario_nuevo = diccionario_nivel

        self.cambiar_diccionario(diccionario_nuevo)
        sizer_1 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        self.diccionario_antiguo = diccionario_nivel
        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)


    def OnBtnDicABC(self, event):  # wxGlade: MyFrame.<event_handler>
        print("if true cambiar bloques a ABC")
        diccionario_nuevo = diccionario_abc

        self.matriz = self.cambiar_diccionario(diccionario_nuevo)
        sizer_1 = wx.GridSizer(0, 0, 0, 0)
        grid_sizer_1 = wx.GridSizer(self.size, self.size, 0, 0)
        grid_sizer_2 = wx.GridSizer(3, 3, 0, 0)
        self.diccionario_antiguo = diccionario_abc
        Matriz.ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, self.matriz)

    def cambiar_diccionario(self, diccionario_nuevo):
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] != " ":
                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    asignar = clave[0]
                    self.matriz[r][c] = diccionario_nuevo[asignar]
        return self.matriz

class Matriz(MiVentana):

    def __init__(self):
        self.matrix = wx.Panel(self, wx.ID_ANY)
        self.matriz = []
        self.__set_properties()
        self.__do_layout()

    def ImprimirTablero(self, sizer_1, grid_sizer_1, grid_sizer_2, matriz):

        for r in range (self.size):
            for c in range (self.size):
                bitmap = wx.StaticBitmap(self.matrix, wx.ID_ANY, wx.Bitmap(matriz[r][c],wx.BITMAP_TYPE_ANY))
                grid_sizer_1.Add(bitmap, 0, wx.ALIGN_CENTRE, 0)
        sizer_1.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.matrix.SetSizer(sizer_1)
        grid_sizer_2.Add(self.matrix, 1, wx.ALIGN_CENTER | wx.LEFT, 194)
        self.matrix.Layout()



    """
     Este metodo nos permitira guardar en una lista las posiciones donde tenemos un "*"
     Parametros de entrada:cadena donde buscar,parametro a buscar
     Parametros de salida: lista que indica el/los lugares(fila o columna) del "*"
    """
    def eleccion(self):
        global movimientos
        #movimientos = movimientos + 1
        self.matriz_auxiliar = self.cambiar_diccionario(diccionario_abc)
        if self.inp == "I" or self.inp == "D":
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = (self.matriz_auxiliar[r][c])
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = self.encontrar(str1, "*")
                self.movimiento(self.matriz, self.size, self.inp, self.diccionario_antiguo, str1, lugar, r, c, nivel)

        else:
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = str(self.matriz_auxiliar[c][r])
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = Matriz.encontrar(str1, "*")
                self.movimiento(self.matriz, self.size, self.inp, self.diccionario_antiguo, str1, lugar, r, c, nivel)

    """
     Este metodo nos permitira recorrer la matriz según el movimiento e ir guardando en un string cada fila o columna
     correspondiente.Ademas sumamos un movimiento y llamamos a cambiar diccionario para segun el modo en el que estemos
     pasemos de forma indirecta al modo alfabeto con el que trabajaremos para los movimientos. Posteriormente llamamos
     una vez que tenemos la cadena a la funcion movimiento.
     Parametros de entrada:matriz, tamano matriz, orden de movimiento,diccionario actual,diccionario de nivel
     Salida: descarga en la funcion movimiento el control
    """


    def encontrar(self, entrada, busqueda):
        l1 = []
        length = len(entrada)
        index = 0
        while index < length:
            i = entrada.find(busqueda, index)
            if i == -1:
                return l1
            l1.append(i)
            index = i + 1
        return l1

    def movimiento(self, matriz, size, inp, diccionario, str1, lugar, r, c, nivel):
        if inp == "S" or inp == "I":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = self.arriba_y_izquierda(cadena, nivel)
                fincad = nuevacad.replace(" ", "")
                self.nueva_matriz(matriz, size, lugar, fincad, inp, diccionario, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = self.arriba_y_izquierda(cadena, nivel)
                        fincad = nuevacad.replace(" ", "")
                        self.nueva_matriz(matriz, size, lugar, fincad, inp, diccionario, r, i, cont)
                        cont = cont + 1
                    i = i + 1

        elif inp == "B" or inp == "D":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = self.abajo_y_derecha(cadena, nivel)
                fincad = nuevacad.replace(" ", "")
                self.nueva_matriz(matriz, size, lugar, fincad, inp, diccionario, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = self.abajo_y_derecha(cadena, nivel)
                        fincad = nuevacad.replace(" ", "")
                        self.nueva_matriz(matriz, size, lugar, fincad, inp, diccionario, r, i, cont)
                        cont = cont + 1
                    i = i + 1

    """
     Este metodo nos permitira trabajar con el string y moldearle como nosotros queremos. Primero analizamos según el tipo
     de movimiento y posteriormente si hemos detectado algun * que se encontraran en lugar.Si no detectamos ninguno, quitamos
     los espacios en blanco, llamamos a la funcion que realiza el movimiento y la fusion y posteriormente volvemos a quitar
     los espacios en blanco y llamamos a nueva matriz que nos genera la matriz resultante. Si hay algun * debemos hacer un paso
     previo de comprobacion si en a hay algun "" que nos indicaria que ha habido dos asteriscos juntos y creamos en este caso
     otro contador que nos indicarian las cadenas que en realidad contienen datos
     Parametros de entrada:matriz, tamano matriz, orden de movimiento,diccionario actual,cadena recibida, lista del lugar
     de los "*" ,contadores de filas y columnas de recorrer la matriz y el diccionario nivel que lo utilizaremos para los puntos.
     Salida: descarga en la funcion nueva_matriz el control que nos proporciona la matriz resultante.
    """

    def abajo_y_derecha(self, cadrecibida, nivel):
        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        if len(cadlista) != 1:
            while puntero > 0:
                if cadlista[puntero] == cadlista[puntero - 1]:
                    cadlista[puntero - 1] = " "
                    a = nivel[cadlista[puntero]]
                    global puntos
                    nuevo = int(a) + 1
                    puntos = puntos + nuevo
                    clave = [key for key, value in nivel.items() if
                             value == str(nuevo)]  # RETURN DE KEY A PARTIR DE VALOR
                    asignar = clave[0]
                    cadlista[puntero] = str(asignar)

                puntero = puntero - 1

        cadena = ''.join(cadlista)
        return cadena

    """
     En este metodo pasamos a una lista la cadena recibida para poder recorrerla y mutarla. Esta al ser la estructura de abajo y derecha
     lo que hacemos es recorrerla de atras hacia delante y miramos si los valores del puntero y el anterior son iguales para
     proceder a su fusion. Si esto sucede mediante el diccionario de nivel accedemos al valor de lo que vale la letra(ya que hemos convertido
     el diccionario actual al diccionario abc para poder trabajar el movimiento) y con esto sumamos los puntos y conseguidos que la fusion
     se lleve acabo.Por ultimo juntamos en un string toda la lista.
     Parametros de entrada:el string sin espacios y el diccionario de nivel.
     Salida: retorna el string ya fusionado.
    """

    def arriba_y_izquierda(self, cadrecibida, nivel):
        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        i = 0
        while i < puntero:
            if cadlista[i] == cadlista[i + 1]:
                cadlista[i + 1] = " "
                a = nivel[cadlista[i]]
                global puntos
                nuevo = int(a) + 1
                puntos = puntos + nuevo
                clave = [key for key, value in nivel.items() if
                         value == str(nuevo)]  # RETURN DE KEY A PARTIR DE VALOR
                asignar = clave[0]
                cadlista[i] = str(asignar)
            i = i + 1

        cadena = ''.join(cadlista)
        return cadena

    # Mismo procedimiento ya comentado en la funcion abajo y derecha. Solo que en este caso empezamos a analizar la
    # cadena de alante hacia atras hasta la longitud maxima de la cadena.

    def nueva_matriz(self, matriz, size, lugar, fincad, inp, diccionario, pos, cont, bucle):
        if inp == "S":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = " "
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = "*"
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[i][pos] = fincad[i]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[0 + contador][pos] == "*":
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[contador + i][pos] = fincad[i]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == "*":
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + i][pos] = diccionario[fincad[i]]

        elif inp == "B":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = " "
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = diccionario["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[size - 1 - i][pos] = diccionario[fincad[len(fincad) - 1 - i]]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[0 + contador][pos] == diccionario["*"]:
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[contador + j][pos] != diccionario["*"]:
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[contador + j - 1 - i][pos] = diccionario[fincad[len(fincad) - 1 - i]]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[0 + contador][pos] != diccionario["*"]:
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[contador - 1 - i][pos] = diccionario[fincad[len(fincad) - 1 - i]]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == diccionario["*"]:
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[lugar[cont - 1] + contador + j][
                        pos] != diccionario["*"]:
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + j - 1 - i][pos] = diccionario[fincad[len(fincad) - 1 - i]]


        elif inp == "I":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = " "
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = diccionario["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][i] = diccionario[fincad[i]]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[pos][0 + contador] == diccionario["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][contador + i] = diccionario[fincad[i]]
                else:
                    contador = 0
                    while (lugar[cont - 1] + contador) <= (size - 1) and matriz[pos][lugar[cont - 1] + contador] == \
                            diccionario["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + i] = diccionario[fincad[i]]

        elif inp == "D":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = " "
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = "*"
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][size - 1 - i] = fincad[len(fincad) - 1 - i]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[pos][0 + contador] == "*":
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[pos][contador + j] != "*":
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador + j - 1 - i] = fincad[len(fincad) - 1 - i]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[pos][0 + contador] != "*":
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador - 1 - i] = fincad[len(fincad) - 1 - i]
                else:
                    contador = 0
                    while matriz[pos][lugar[cont - 1] + contador] == "*":
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[pos][
                        lugar[cont - 1] + contador + j] != "*":
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + j - 1 - i] = fincad[len(fincad) - 1 - i]

    """
     En este proceso lo que realizamos es según el movimiento indicado, introducir los valores que formaran la nueva matriz.
     Lo primero que haremos será limpiar la matriz y llenar los huecos que tenian asteriscos haciendo caso del lugar donde estaban.
     Lo siguiente sera introducir las cadenas. Para ello distinguimos si es sin asteriscos o con ellos, ya que en el primer caso
     no debemos tener "cuidado" de las posiciones iniciales de las cadenas. En cuanto al segundo caso mediante desarollamos un algoritmo
     mediante el cual comprueba si se trata de la primera cadena u otra. Si es la primera empezamos a introducir los valores de esta justo
     tras los asteriscos pertinentes( para lo cual desarrollamos un contador para saber la poscion exacta donde empezar).Sino se trata de
     la primera cadena con otro contador de nuevo contamos desde la ultima posicion del asterisco correspondiente al indice que traemos
     por entrada. Y posteriormente esa cadeana la introducimos a partir de ese indica mas el contador.
     Parametros de entrada:la matriz,su tamano,lista con el lugar de los *,diccionario actual, la columna o fila donde se deben introducir,
     el contador de la cadena una vez separada tras los * y el otro contador que almacena el anterior pero sin contar donde la posicion del
     vector sea "".
     Salida: modifica los valores de la matriz a imprimir
    """
    def comparar(self, matriz, matriz_comparar, size):
        iguales = True
        for r in range(size):
            for c in range(size):
                if (matriz[r][c] != matriz_comparar[r][c]):
                    iguales = False

        return iguales

    """
     Esta funcion lo que hace es comparar si las dos matrices de entrada: la que teniamos comparada con la actualizada tras el movimiento
     Si son iguales en todos los elementos devuelve True, sino False.
     Precondicion: Las dos matrices tienen el mismo tamano
     Parametros de entrada:la matriz antigua y la actual y su tamaño
     Salida: boolean que nos indicara si todos sus elementos son iguales

"""




# end of class MiVentana

class MyApp(wx.App):
    def OnInit(self):
        self.frame_20148 = MiVentana(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame_20148)
        self.frame_20148.Show()
        return True

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
