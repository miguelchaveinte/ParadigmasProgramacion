
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.5 on Sat Apr 18 15:40:29 2020
#

'''
CURSO:2019/2020
ASIGNATURA: PARADIGMAS DE PROGRAMACION
GRUPO 3
PRACTICA 2:El tercer clon (II).
@author: MIGUEL CHAVEINTE GARCIA.
@author: ABDURRAHIM ALI ALI.
'''

import wx.lib.agw.shapedbutton as SB
import wx
import random
import copy
from playsound import playsound


# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade
#


diccionario_2048 = {"A": "imagenes/3-1.png", "B": "imagenes/3-2.png", "C": "imagenes/3-3.png", "D": "imagenes/3-4.png",
                    "E": "imagenes/3-5.png", "F": "imagenes/3-6.png",
                    "G": "imagenes/3-7.png", "H": "imagenes/3-8.png", "I": "imagenes/3-9.png",
                    "J": "imagenes/3-10.png",
                    "K": "imagenes/3-11.png", ".": "imagenes/Vacio.png", "*": "imagenes/Bloque.png"}
diccionario_1024 = {"A": "imagenes/2-1.png", "B": "imagenes/2-2.png", "C": "imagenes/2-3.png", "D": "imagenes/2-4.png",
                    "E": "imagenes/2-5.png", "F": "imagenes/2-6.png",
                    "G": "imagenes/2-7.png", "H": "imagenes/2-8.png", "I": "imagenes/2-9.png",
                    "J": "imagenes/2-10.png",
                    "K": "imagenes/2-11.png", ".": "imagenes/Vacio.png", "*": "imagenes/Bloque.png"}
diccionario_abc = {"A": "imagenes/0-1.png", "B": "imagenes/0-2.png", "C": "imagenes/0-3.png", "D": "imagenes/0-4.png",
                   "E": "imagenes/0-5.png", "F": "imagenes/0-6.png",
                   "G": "imagenes/0-7.png", "H": "imagenes/0-8.png", "I": "imagenes/0-9.png",
                   "J": "imagenes/0-10.png",
                   "K": "imagenes/0-11.png", ".": "imagenes/Vacio.png", "*": "imagenes/Bloque.png"}
diccionario_nivel = {"A": "imagenes/1-1.png", "B": "imagenes/1-2.png", "C": "imagenes/1-3.png", "D": "imagenes/1-4.png",
                     "E": "imagenes/1-5.png", "F": "imagenes/1-6.png",
                     "G": "imagenes/1-7.png", "H": "imagenes/1-8.png", "I": "imagenes/1-9.png",
                     "J": "imagenes/1-10.png",
                     "K": "imagenes/1-11.png", ".": "imagenes/Vacio.png", "*": "imagenes/Bloque.png"}

diccionario_puntos = {"B": "2", "C": "3", "D": "4", "E": "5", "F": "6", "G": "7", "H": "8", "I": "9",
                      "J": "10", "K": "11"}

diccionario_fusión = {"A": "B", "B": "C", "C": "D", "D": "E", "E": "F", "F": "G", "G": "H", "H": "I", "I": "J",
                      "J": "K"}

cambio=False

class MyDialog(wx.Dialog):
    """"""

    # ----------------------------------------------------------------------
    def __init__(self):
        """Constructor del cuadro de dialogo para pedir datos para la nueva partida"""
        wx.Dialog.__init__(self, None, title="Datos Matriz")
        self.comboBox1 = wx.SpinCtrl(self, wx.ID_ANY, "")
        self.comboBox2 = wx.SpinCtrl(self, wx.ID_ANY, "")
        okBtn = wx.Button(self, label="OK")
        label_1 = wx.StaticText(self, wx.ID_ANY, "DIMENSIÓN MATRIZ:")
        label_2 = wx.StaticText(self, wx.ID_ANY, "Nº BLOQUES:")
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(label_1, 0, wx.ALL | wx.CENTER, 5)
        sizer.Add(self.comboBox1, 0, wx.ALL | wx.CENTER, 2)
        sizer.Add(label_2, 0, wx.ALL | wx.CENTER, 5)
        sizer.Add(self.comboBox2, 0, wx.ALL | wx.CENTER, 2)
        okBtn.Bind(wx.EVT_BUTTON, self.guardar)
        sizer.Add(okBtn, 0, wx.ALL | wx.CENTER, 2)
        self.SetSizer(sizer)


    def guardar(self,event):
        """ Docstring
            :param self:  Contiene todas las variables que necesitamos.
            :param event: Recoge la pulsacion de del boton Ok
            :arg Se trata de recoger si ha existido esa pulsación o por el contrario
            se ha cerrado la ventana porque el usuario finalmente no quería crear otra partida.Se recoge
            en la variable global cambio que actualizamos si se ha pulsado OK y finalmente destruimos el
            dialogo
        """
        global cambio
        cambio=True
        self.Destroy()

class EndDialog(wx.Dialog):
    """"""

    # ----------------------------------------------------------------------
    def __init__(self):
        """Constructor del dialogo cuando la partida finaliza """
        wx.Dialog.__init__(self, None, title="Juego acabado!")

        jugr_otr_vz = wx.Button(self, wx.ID_OK, "Volver a jugar")
        salir = wx.Button(self, wx.ID_CANCEL, "Salir")
        txt_acabado = wx.StaticText(self, wx.ID_ANY, "EL JUEGO HA ACABADO!")

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(txt_acabado, 0, wx.ALL | wx.CENTER, 5)
        sizer.Add(jugr_otr_vz, 0, wx.ALL | wx.CENTER, 2)
        sizer.Add(salir, 0, wx.ALL | wx.CENTER, 2)
        self.SetSizer(sizer)


class DialogoInstrucciones(wx.Dialog):
    """"""

    # ----------------------------------------------------------------------
    def __init__(self):
        """Constructor del dialogo que mostramos al inicio con las instrucciones"""
        wx.Dialog.__init__(self, None, title="HOLA!, SOY LAS INSTRUCCIONES!")
        ok = wx.Button(self, wx.ID_OK, "OK")
        self.check = wx.CheckBox(self, label="No volver a mostrar")
        txt_acabado = wx.StaticText(self, wx.ID_ANY,
                                    "\n\n                                       CAUTION!!! : INSTALE LA LIBRERÍA  "
                                    "PLAYSOUND PARA EJECUTAR LOS SONIDOS.\n"
                                    "\n\n-LOS BLOQUES SE MUEVEN CON LAS FLECHAS DE DIRECCIóN.\n"
                                    "\n-EN LA ESQUINA IZQUIERDA ARRIBA APARECEN UNA SERIE DE BOTONES:\n"
                                    "\n-EL PRIMERO "
                                    "ES POR SI TE APETECE EMPEZAR UNA NUEVA PARTIDA CON LAS "
                                    "DIMENSIONES Y NÚMEROS DE BLOQUES QUE QUIERAS.\n"
                                    "\n-EL SEGUNDO ES PARA PODER CARGAR ESA PARTIDA QUE GUARDASTE ANTES.\n"
                                    "\n-EL TERCERO ES PARA QUE GUARDES TU PROGRESO EN CASO DE QUE QUIERAS CONTINUAR "
                                    "TU PARTIDA MÁS TARDE.\n"
                                    "\n-CON EL SIGUIENTE BOTÓN PUEDES RETROCEDER UNA JUGADA ATRÁS!\n"
                                    "\n-POR ÚLTIMO, JUNTO A TU PUNTUACION Y MOVIMIENTOS QUE HAS REALIZADO,"
                                    "VERÁS UNA SERIE DE OPCIONES\n TALES COMO: ABC, NIVEL... "
                                    "ESTO ES POR SI QUIERES CAMBIAR EL ASPECTO DE LOS BLOQUES.\n")
        txt_acabado.SetFont(
            wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Segoe UI"))

        sizer = wx.BoxSizer(wx.VERTICAL)

        sizer.Add(txt_acabado, 0, wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL, 5)
        sizer.Add(self.check, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 2)
        sizer.Add(ok, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 2)

        self.Bind(wx.EVT_CHECKBOX, self.onChecked)

        self.SetSizerAndFit(sizer)

    def onChecked(self, event):
        """Si detecta que checkeamos el marco de no volver a mostrar escribimos en el archivo
        check.txt: true para que cuando vuelvas a iniciar el juego una vez cerrado no te aparezca el mensaje"""
        if self.check.IsChecked():
            check = open("archextra/check.txt", "w+")
            check.write("True")
            check.close()


class MiVentana(wx.Frame):
    """Clase relacionada con la ventana  del juego y los eventos que se producen"""

    def __init__(self, *args, **kwds):
        # begin wxGlade: MiVentana.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((900, 600))
        self.newsheet_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("imagenes/newsheet.ico", wx.BITMAP_TYPE_ICO))
        self.open_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("imagenes/abrir.ico", wx.BITMAP_TYPE_ICO))
        self.save_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("imagenes/save.ico", wx.BITMAP_TYPE_ICO))
        self.undo_button = wx.BitmapButton(self, wx.ID_ANY, wx.Bitmap("imagenes/undo.ico", wx.BITMAP_TYPE_ICO))
        self.radio_btn_2048 = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_abc = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_nivel = wx.RadioButton(self, wx.ID_ANY, "")
        self.radio_btn_1024 = wx.RadioButton(self, wx.ID_ANY, "")
        self.matrix = wx.Panel(self, wx.ID_ANY)
        self.ya_le_has_dado = False
        self.has_cargado = False

        self.size = 4
        self.obstaculos = 2
        self.matriz = Matriz.crearMatriz(self)

        self.__set_properties()
        self.__do_layout()
        movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
        self.label_movs.SetLabelText(movimientos_str)
        puntos_str = str("PUNTOS: " + str(self.puntos))
        self.label_puntos.SetLabelText(puntos_str)


        self.Bind(wx.EVT_CLOSE,self.OnClose)
        self.Bind(wx.EVT_BUTTON, self.OnBtnSave, self.save_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnNewMatrix, self.newsheet_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnUndo, self.undo_button)
        self.Bind(wx.EVT_BUTTON, self.OnBtnOpen, self.open_button)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic2048, self.radio_btn_2048)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDic1024, self.radio_btn_1024)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicNivel, self.radio_btn_nivel)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnBtnDicABC, self.radio_btn_abc)

        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: MiVentana.__set_properties
        self.SetTitle("2048")
        self.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.newsheet_button.SetSize(self.newsheet_button.GetBestSize())

        self.open_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.open_button.SetSize(self.open_button.GetBestSize())
        self.save_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.save_button.SetSize(self.save_button.GetBestSize())
        self.undo_button.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.undo_button.SetSize(self.undo_button.GetBestSize())
        self.radio_btn_2048.SetValue(1)
        self.radio_btn_nivel.SetFont(
            wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, 0, "Segoe UI"))
        self.matrix.SetMinSize((1000, 1000))
        self.matrix.SetBackgroundColour(wx.Colour("black"))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MiVentana.__do_layout
        self.sizer_4 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_16 = wx.BoxSizer(wx.HORIZONTAL)
        self.grid_sizer_3 = wx.GridSizer(3, 3, 0, 0)
        self.sizer_6 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_7 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_14 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, "MODO"), wx.HORIZONTAL)
        self.grid_sizer_2 = wx.GridSizer(4, 2, 0, 0)
        self.sizer_8 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_9 = wx.StaticBoxSizer(wx.StaticBox(self, wx.ID_ANY, u"INFORMACIÓN"), wx.HORIZONTAL)
        self.sizer_15 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_1 = wx.BoxSizer(wx.VERTICAL)
        self.grid_sizer_1 = wx.GridSizer(1, 4, 0, 0)
        self.sizer_13 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_12 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_11 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_10 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_10.Add(self.newsheet_button, 1, wx.ALIGN_CENTER, 14)
        self.sizer_10.Add((0, 0), 0, 0, 0)
        self.grid_sizer_1.Add(self.sizer_10, 0, wx.EXPAND, 0)
        self.sizer_11.Add(self.open_button, 1, wx.ALIGN_CENTER | wx.ALL, 14)
        self.sizer_11.Add((0, 0), 0, 0, 0)
        self.grid_sizer_1.Add(self.sizer_11, 0, wx.EXPAND, 0)
        self.sizer_12.Add(self.save_button, 1, wx.ALIGN_CENTER | wx.ALL, 14)
        self.sizer_12.Add((0, 0), 0, 0, 0)
        self.grid_sizer_1.Add(self.sizer_12, 0, wx.EXPAND, 0)
        self.sizer_13.Add(self.undo_button, 1, wx.ALIGN_CENTER | wx.ALL, 14)
        self.sizer_13.Add((0, 0), 0, 0, 0)
        self.grid_sizer_1.Add(self.sizer_13, 0, wx.EXPAND, 0)
        self.sizer_8.Add(self.grid_sizer_1, 0, wx.EXPAND, 0)
        label_2 = wx.StaticText(self, wx.ID_ANY, "AUTORES:\nMIGUEL Y ABDU")
        label_2.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.sizer_15.Add(label_2, 1, 0, 0)
        self.label_movs = wx.StaticText(self, wx.ID_ANY, "")
        self.label_movs.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.sizer_1.Add(self.label_movs, 1, wx.ALIGN_CENTER | wx.ALL, 0)
        self.label_puntos = wx.StaticText(self, wx.ID_ANY, "", style=wx.ALIGN_LEFT)
        self.label_puntos.SetFont(wx.Font(10, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.sizer_1.Add(self.label_puntos, 1, wx.ALIGN_CENTER | wx.ALL, 0)
        self.sizer_15.Add(self.sizer_1, 1, wx.EXPAND, 0)
        self.sizer_9.Add(self.sizer_15, 1, wx.EXPAND, 0)
        self.sizer_8.Add(self.sizer_9, 0, wx.EXPAND, 0)
        self.sizer_6.Add(self.sizer_8, 0, wx.EXPAND, 0)
        label_2048 = wx.StaticText(self, wx.ID_ANY, "2048", style=wx.ALIGN_CENTER)
        label_2048.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.grid_sizer_2.Add(label_2048, 1, wx.ALIGN_CENTER | wx.ALL, 20)
        self.grid_sizer_2.Add(self.radio_btn_2048, 1, wx.ALIGN_CENTER | wx.ALL, 10)
        label_abc = wx.StaticText(self, wx.ID_ANY, "ABC")
        label_abc.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.grid_sizer_2.Add(label_abc, 1, wx.ALIGN_CENTER | wx.ALL, 20)
        self.grid_sizer_2.Add(self.radio_btn_abc, 0, wx.ALIGN_CENTER, 0)
        label_nivel = wx.StaticText(self, wx.ID_ANY, "NIVEL")
        label_nivel.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.grid_sizer_2.Add(label_nivel, 1, wx.ALIGN_CENTER | wx.ALL, 20)
        self.grid_sizer_2.Add(self.radio_btn_nivel, 0, wx.ALIGN_CENTER | wx.ALL, 0)
        label_1024 = wx.StaticText(self, wx.ID_ANY, "1024")
        label_1024.SetFont(wx.Font(16, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Segoe UI"))
        self.grid_sizer_2.Add(label_1024, 1, wx.ALIGN_CENTER | wx.ALL, 20)
        self.grid_sizer_2.Add(self.radio_btn_1024, 0, wx.ALIGN_CENTER | wx.ALL, 0)
        self.sizer_14.Add(self.grid_sizer_2, 1, wx.EXPAND, 0)
        self.sizer_7.Add(self.sizer_14, 1, wx.ALL | wx.EXPAND, 0)
        self.sizer_6.Add(self.sizer_7, 1, wx.EXPAND, 0)
        self.sizer_5.Add(self.sizer_6, 0, wx.EXPAND, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)

        Matriz.ImprimirTablero(self)

        self.matrix.SetFocus()
        self.matrix.Bind(wx.EVT_CHAR_HOOK, self.mover)

        self.sizer_4.Add(self.sizer_5, 1, wx.EXPAND, 0)

        self.SetSizer(self.sizer_4)
        self.Layout()

        # end wxGlade

    def OnBtnNewMatrix(self, event):
        """ Docstring
        :param self:  Contiene todas las variables que necesitamos.
        :arg Se trata del handler del boton de crear una nueva matriz, entonces al presionarlo, llamamos al dialogo
        que se encarga de preguntar al usuario el tamano y el numero de obstaculos para el nuevo tablero.
        Una vez hecho esto, creamos ese nuevo tablero, ponemos a 0 los movimientos y puntos y nos preparamos
        para mostrar por pantalla el tablero.
        """
        dlg = MyDialog()
        dlg.ShowModal()
        global cambio
        if cambio==True:
            self.size = dlg.comboBox1.GetValue()
            self.obstaculos = dlg.comboBox2.GetValue()

            if self.size>4 and self.size<=9:
                self.SetSize((1200, 700))
            elif self.size<3:
                self.SetSize((750, 500))
            elif self.size>9 and self.size<=13:
                self.SetSize((1500, 900))
            elif self.size>13:
                self.SetSize((3000, 3000))
            elif self.size==4 or self.size==3:
                self.SetSize((900, 600))
            self.matriz = Matriz.crearMatriz(self)
            Matriz.before(self)
            self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
            self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
            self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
            Matriz.ImprimirTablero(self)
            self.puntos = 0
            puntos_str = str("PUNTOS: " + str(self.puntos))
            self.label_puntos.SetLabelText(puntos_str)
            self.movimientos = 0
            movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
            self.label_movs.SetLabelText(movimientos_str)
            self.matrix.SetFocus()
            self.has_cargado=True
            self.radio_btn_2048.SetValue(1)
            self.radio_btn_abc.SetValue(0)
            self.radio_btn_1024.SetValue(0)
            self.radio_btn_nivel.SetValue(0)

        self.matrix.SetFocus()
        cambio = False

    def mover(self, event):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :param event: Recoge la pulsacion de teclado en forma de codigo y nos dice que tecla se ha pulsado
                :arg Se trata del handler del movimiento, al pulsar una flecha de direccion, llamamos a este metodo.
                Se encarga de reproducir el sonido y de llamar a los siguientes metodos anidados para realizar
                el movimiento. Tambien se encarga de llamar a la funcion de finalizacion del juego en caso de que
                se cumpla cierta condicion.
                """
        self.ya_le_has_dado = False
        self.matriz_previa = copy.deepcopy(self.matriz)  # copiamos la matriz antes de realizar el movimiento
        self.puntos_previos = self.puntos
        codigo_tecla = event.GetKeyCode()

        if codigo_tecla == wx.WXK_UP:
            self.inp = "S"
            self.moverTablero()
            self.juego_acabado = Matriz.endGame(self)
            if self.juego_acabado == True:
                self.ReinciarJuego()

        elif codigo_tecla == wx.WXK_DOWN:
            self.inp = "B"
            self.moverTablero()
            self.juego_acabado = Matriz.endGame(self)
            if self.juego_acabado == True:
                self.ReinciarJuego()
        elif codigo_tecla == wx.WXK_LEFT:
            self.inp = "I"
            self.moverTablero()
            self.juego_acabado = Matriz.endGame(self)
            if self.juego_acabado == True:
                self.ReinciarJuego()
        elif codigo_tecla == wx.WXK_RIGHT:
            self.inp = "D"
            self.moverTablero()
            self.juego_acabado = Matriz.endGame(self)
            if self.juego_acabado == True:
                self.ReinciarJuego()


    def ReinciarJuego(self):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del metodo que se va a ejecutar en caso de que el juego termine
                si el usuario ha llegado a la ficha de maximo nivel o si no existe fusion o movimiento.
                Se abrira un dialogo que nos permitira crear un nuevo tablero o detener el juego directamente.
                """
        dlg = EndDialog()
        res = dlg.ShowModal()
        if res == wx.ID_OK:
            dlg.Destroy()
            dlg_new = MyDialog()
            res_1 = dlg_new.ShowModal()
            global cambio
            if cambio == True:
                self.size = dlg_new.comboBox1.GetValue()
                self.obstaculos = dlg_new.comboBox2.GetValue()
                self.matriz = Matriz.crearMatriz(self)
                if self.size > 4 and self.size <= 9:
                    self.SetSize((1200, 700))
                elif self.size < 3:
                    self.SetSize((750, 500))
                elif self.size > 9 and self.size <= 13:
                    self.SetSize((1500, 900))
                elif self.size > 13:
                    self.SetSize((3000, 3000))
                elif self.size == 4 or self.size == 3:
                    self.SetSize((900, 600))
                Matriz.before(self)
                self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
                self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
                self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
                Matriz.ImprimirTablero(self)
                self.puntos = 0
                puntos_str = str("PUNTOS: " + str(self.puntos))
                self.label_puntos.SetLabelText(puntos_str)
                self.movimientos = 0
                movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
                self.label_movs.SetLabelText(movimientos_str)
                self.matrix.SetFocus()
                self.has_cargado = True
                self.radio_btn_2048.SetValue(1)
                self.radio_btn_abc.SetValue(0)
                self.radio_btn_1024.SetValue(0)
                self.radio_btn_nivel.SetValue(0)

            dlg_new.Destroy()
        elif dlg.ShowModal() == wx.ID_CANCEL:
            exit()

    def moverTablero(self):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del metodo que copia la matriz anterior y tras realizar un movimiento ve si esta ha cambiado.
                Si esta ha cambiado se imprime la matriz resultante,se  suma un movimiento y los puntos si proceden
                y los sonidos que correspondan. Si no ha cambiado se deja todo igual y se emite el sonido de que se ha
                detectado pulsacion de tecla pero se ha dejado la matriz igual. El proceso de generar la nueva matriz
                se produce llamando a Matriz.elección.
                """
        matriz_comparar = copy.deepcopy(self.matriz)  # copiamos la matriz antes de realizar el movimiento
        Matriz.eleccion(self, self.matriz,
                        self.inp)  # llamamos a la funcion que nos realizara todo aquello referente al movimiento
        igual = Matriz.comparar(self, self.matriz, matriz_comparar,
                                self.size)  # llamamos a la funcion comparar que nos dira si la matriz anterior y la actual son iguales
        if igual:
            try:
                playsound("archextra/sonido_arrastrar.wav")
            except:
                pass

            movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
            self.label_movs.SetLabelText(movimientos_str)
        else:
            try:
                playsound("archextra/sonido_arrastrar.wav")
            except:
                pass

            self.matriz = Matriz.new_values(self)  # si  no es igual introducimos tras el movimiento un nuevo valor aleatorio entre 2 y 4 en una posicio
            self.movimientos = self.movimientos + 1
            movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
            self.label_movs.SetLabelText(movimientos_str)
            try:
                playsound("archextra/aparicion_bloque.wav")
            except:
                pass

            self.has_cargado = False

            Matriz.before(self)
            self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
            self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
            self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
            Matriz.ImprimirTablero(self)


    def OnClose(self,event):
        self.Destroy()
        exit()

    def OnBtnOpen(self, event):

        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del handler del boton de cargar una partida anteriormente guardada, llamamos a wx.FileDialog
                que permite crear dialogos del tipo navegar por los directorios que detecta el ordenador, nos permite seleccionar
                archivos de texto, que es donde guardamos las partidas junto con la puntuacion y movimientos.
                Para cargar la partida, abrimos el archivo y vamos leyendo linea a linea, rellenando la matriz que despues
                sera la matriz que se va modificando a lo largo de la partida y con ella sale el tablero en pantalla.
                """

        r = -1
        direccion = wx.FileDialog(self, "Cargar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                                  style=wx.FD_OPEN)

        if direccion.ShowModal() == wx.ID_CANCEL:
            self.matrix.SetFocus()
            return
        self.matriz = []
        self.has_cargado=True
        partida = open(direccion.GetPath(), "r+")
        self.size = int(partida.readline())
        self.movimientos = int(partida.readline())
        movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
        self.label_movs.SetLabelText(movimientos_str)
        self.puntos = int(partida.readline())
        puntos_str = str("PUNTOS: " + str(self.puntos))
        self.label_puntos.SetLabelText(puntos_str)
        self.matrix.SetFocus()

        for i in range(self.size):
            self.matriz.append([" "] * self.size)

        for position, line in enumerate(partida):

            r += 1

            for c in range(self.size):
                char = line[c]

                self.matriz[r][c] = diccionario_2048[char]

        partida.close()
        self.diccionario_antiguo = diccionario_2048
        if self.size > 4 and self.size <= 9:
            self.SetSize((1200, 700))
        elif self.size < 3:
            self.SetSize((750, 500))
        elif self.size > 9 and self.size <= 13:
            self.SetSize((1500, 900))
        elif self.size > 13:
            self.SetSize((3000, 3000))
        elif self.size == 4 or self.size == 3:
            self.SetSize((900, 600))
        Matriz.before(self)
        self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        Matriz.ImprimirTablero(self)
        self.matrix.SetFocus()
        self.radio_btn_2048.SetValue(1)
        self.radio_btn_abc.SetValue(0)
        self.radio_btn_1024.SetValue(0)
        self.radio_btn_nivel.SetValue(0)

    def OnBtnSave(self, event):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del handler del boton de guardar la partida actual, nos servimos de wx.FileDialog,
                que nos permite generar un dialogo capaz de navegar entre los distintos directorios.
                Una vez elegido el lugar donde se vaya a almacenar la partida, con un archivo de texto
                recogemos la informacion relacionada con la partida, movimientos, puntuacion, tamano de matriz
                y por supuesto la disposicion de los bloques.
                """
        fileDialog = wx.FileDialog(self, "Guardar partida", wildcard="Archivo .txt (*.txt)|*.txt",
                                   style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)

        if fileDialog.ShowModal() == wx.ID_CANCEL:
            self.matrix.SetFocus()
            return
        nombre_usr = fileDialog.GetPath()
        try:
            archivo = open(nombre_usr, 'w+')
            archivo.write(str(self.size))
            archivo.write("\n")
            archivo.write(str(self.movimientos))
            archivo.write("\n")
            archivo.write(str(self.puntos))
            archivo.write("\n")
            for r in range(self.size):
                for c in range(self.size):

                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    archivo.write(clave[0])

                    if c == self.size - 1:
                        archivo.write("\n")

            archivo.close()
            self.matrix.SetFocus()
        except IOError:
            wx.LogError("No se puede guardar aqui: '%s'." % nombre_usr)
            self.matrix.SetFocus()

    def OnBtnUndo(self, event):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del handler del boton que nos permite retroceder una jugada atras, esta gobernado por un booleano
                para que solamente se pueda ir una unica vez atras por movimiento, este booleano cambia de valor al mover el tablero
                pero una vez pulsado este boton, cambia de valor y no permite retroceder tantas veces como se quiera sino solo una.
                """
        if self.ya_le_has_dado == False:
            if self.has_cargado == True:
                self.matrix.SetFocus()
                return
            try:
                self.matriz = self.matriz_previa
                self.matrix.SetFocus()
            except:
                self.matrix.SetFocus()
                return
            self.puntos = self.puntos_previos
            self.movimientos = self.movimientos - 1
            movimientos_str = str("MOVIMIENTOS: " + str(self.movimientos))
            self.label_movs.SetLabelText(movimientos_str)

            puntos_str = str("PUNTOS: " + str(self.puntos))
            self.label_puntos.SetLabelText(puntos_str)
            Matriz.before(self)
            self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
            self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
            self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
            Matriz.ImprimirTablero(self)
            self.matrix.SetFocus()
            self.has_cargado = False

            self.ya_le_has_dado = True
        else:
            self.matrix.SetFocus()
            return


    def OnBtnDic2048(self, event):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del handler del boton para cambiar el aspecto de los bloques, simplemente cambiamos
                el diccionario que se esta utilizando actualmente y llamamos a los metodos de cambiar diccionario
                que iterando con diccionarios son capaces de cambiar la matriz y por tanto el aspecto de los bloques.
                """
        diccionario_nuevo = diccionario_2048

        self.cambiar_diccionario(diccionario_nuevo)
        self.diccionario_antiguo = diccionario_2048

        Matriz.before(self)
        self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        Matriz.ImprimirTablero(self)
        self.matrix.SetFocus()

    def OnBtnDic1024(self, event):
        """Mismo procedimiento que para OnBtnDic2048"""
        diccionario_nuevo = diccionario_1024
        self.cambiar_diccionario(diccionario_nuevo)
        self.diccionario_antiguo = diccionario_1024

        Matriz.before(self)
        self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        Matriz.ImprimirTablero(self)
        self.matrix.SetFocus()

    def OnBtnDicNivel(self, event):
        """Mismo procedimiento que para OnBtnDic2048"""

        diccionario_nuevo = diccionario_nivel

        self.cambiar_diccionario(diccionario_nuevo)
        self.diccionario_antiguo = diccionario_nivel

        Matriz.before(self)
        self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        Matriz.ImprimirTablero(self)
        self.matrix.SetFocus()

    def OnBtnDicABC(self, event):
        """Mismo procedimiento que para OnBtnDic2048"""
        diccionario_nuevo = diccionario_abc

        self.matriz = self.cambiar_diccionario(diccionario_nuevo)
        self.diccionario_antiguo = diccionario_abc

        Matriz.before(self)
        self.sizer_16 = wx.GridSizer(0, 0, 0, 0)
        self.grid_sizer_3 = wx.GridSizer(self.size, self.size, 0, 0)
        self.sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        Matriz.ImprimirTablero(self)
        self.matrix.SetFocus()

    def cambiar_diccionario(self, diccionario_nuevo):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :param diccionario_nuevo: Se trata de el diccionario al que el usuario quiere cambiar.
                :arg Se trata del metodo que se llama cuando el usuario llama al handler de alguno de los cambios de diccionario.
                Es bastante simple, recibe el nuevo diccionario y en self.diccionario_antiguo se almacena el que se usa
                previamente, entonces, iterando con ellos y recorriendo la matriz, se consigue cambiar el aspecto de los bloques.
                """
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] != " ":
                    clave = [key for key, value in self.diccionario_antiguo.items() if
                             value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                    asignar = clave[0]
                    self.matriz[r][c] = diccionario_nuevo[asignar]
        return self.matriz


class Matriz(MiVentana):

    def __init__(self):
        self.matrix = wx.Panel(self, wx.ID_ANY)

    def crearMatriz(self):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del metodo que vamos a llamar siempre y cuando querramos generar un nuevo tablero, es sencillo
                recoge los parametros de tamano y obstaculos y con el diccionario por defecto(2048) genera una matriz
                con 2 bloques segun cierta probabilidad y genera bloques inmoviles que son los obstaculos.
                :return matriz
                """
        matriz = []
        z = 0
        l = 0
        for i in range(self.size):
            matriz.append([" "] * self.size)
        while z < self.obstaculos:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if matriz[rand_r][rand_c] == " ":
                matriz[rand_r][rand_c] = diccionario_2048["*"]
                z = z + 1
        while l < 2:
            rand_r = random.randint(0, self.size - 1)
            rand_c = random.randint(0, self.size - 1)
            if matriz[rand_r][rand_c] != diccionario_2048["*"]:
                matriz[rand_r][rand_c] = diccionario_2048["A"]
                l = l + 1
        for r in range(self.size):
            for c in range(self.size):
                if matriz[r][c] == " ":
                    matriz[r][c] = diccionario_2048["."]
        self.diccionario_antiguo = diccionario_2048
        self.puntos = 0
        self.movimientos = 0
        return matriz

    def ImprimirTablero(self):
        """ Docstring
                :param self:  Contiene todas las variables que necesitamos.
                :arg Se trata del metodo que se llama cada vez que se mueven los bloques o se genera un nuevo tablero o se cambia
                el aspecto del mismo, se trata de, recorriendo la matriz, ir incluyendo en el sizer que ha sido dividido antes
                cada una de las imagenes que van a conformar el tablero, todo esto ocurre sobre un panel y finalmente se llama
                a la opcion de Layout, que muestra este panel en pantalla.
                """
        for r in range(self.size):
            for c in range(self.size):
                bitmap = wx.StaticBitmap(self.matrix, wx.ID_ANY, wx.Bitmap(self.matriz[r][c], wx.BITMAP_TYPE_ANY))
                self.grid_sizer_3.Add(bitmap, 0, wx.ALIGN_CENTER, 0)

        self.sizer_16.Add(self.grid_sizer_3, 1, wx.EXPAND, 0)
        self.matrix.SetSizer(self.sizer_16)
        self.sizer_5.Add(self.matrix, 1, wx.ALIGN_CENTER, 0)
        self.matrix.Layout()

    def before(self):
        children = self.grid_sizer_3.GetChildren()
        for child in children:
            widget = child.GetWindow()
            if isinstance(widget, wx.StaticBitmap):
                widget.Destroy()
        self.grid_sizer_3.Layout()

    def new_values(self):
        """ Docstring
        :param self: Contiene todos los parametros necesarios, tales como tamano, diccionario actual y matriz

        :arg Recibimos una matriz y nos ayudamos de un booleano en este caso val_in, lo utilizamos como condicion en un bucle
        while para asegurar que hemos podido calcular una posicion aleatoria y vacia y hemos insertado el nuevo bloque, con las
        probabilidades correspondientes.


        :return: matriz: Devolvemos una matriz con un nuevo bloque insertado.
        """
        val_in = False
        select_val = random.random()
        if select_val <= 0.75:
            new_val = self.diccionario_antiguo["A"]
        else:
            new_val = self.diccionario_antiguo["B"]
        while val_in != True:
            rrand = random.randint(0, self.size - 1)
            crand = random.randint(0, self.size - 1)
            if self.matriz[rrand][crand] == self.diccionario_antiguo["."]:
                self.matriz[rrand][crand] = new_val
                val_in = True
        return self.matriz

    def endGame(self):
        """ Docstring
        :param self: Recibimos todos los paramtros medinate este,matriz para recorrerla, su tamano y el diccionario usado ahora mismo

        :arg: En este metodo lo que realizamos son una serie de comprobaciones esenciales para poder saber si el programa
        debe detener su ejecucion, nos basamos en recibir la matriz con el nuevo bloque ya insertado y comprobamos que
        no existe un espacio en blanco disponible y que no hay fusion posible, cuando se cumplen estos requisitos, devolvemos
        un True y con esto  acaba la ejecucion del codigo. Tambien si al recorrer la matriz conseguimos encontrar un bloque
        de nivel maximo, con esto el juego tambien concluye.

        :return: endGame, es un booleano que nos permite saber si el juego ha terminado o no.
        """
        endGame = False
        fusion = False
        continua = False
        for r in range(self.size):
            for c in range(self.size):
                if self.matriz[r][c] == self.diccionario_antiguo["."] and self.matriz[r][c] != self.diccionario_antiguo[
                    "*"]:
                    continua = True
        for r in range(self.size):
            for c in range(self.size):
                valor = self.matriz[r][c]
                if valor == self.diccionario_antiguo["K"]:
                    endGame = True
                    return endGame
        for r in range(self.size):
            for c in range(self.size - 1):
                if self.matriz[r][c] == self.matriz[r][c + 1] and self.matriz[r][c] != self.diccionario_antiguo["*"]:
                    fusion = True
        for c in range(self.size):
            for r in range(self.size - 1):
                if self.matriz[r][c] == self.matriz[r + 1][c] and self.matriz[r][c] != self.diccionario_antiguo["*"]:
                    fusion = True
        if continua == True:
            endGame = False
            return endGame
        if continua == False and fusion == False:
            endGame = True
        if continua == False and fusion == True:
            endGame = False
        return endGame



    def eleccion(self, matriz, inp):
        """
         Este metodo nos permitira recorrer la matriz según el movimiento e ir guardando en un string cada fila o columna
         correspondiente.Ademas sumamos un movimiento y llamamos a cambiar diccionario para segun el modo en el que estemos
         pasemos de forma indirecta al modo alfabeto con el que trabajaremos para los movimientos. Posteriormente llamamos
         una vez que tenemos la cadena a la funcion movimiento.
         Parametros de entrada:self,matriz, tamano matriz, orden de movimiento,diccionario actual,diccionario de nivel
         Salida: descarga en la funcion movimiento el control
        """

        matriz_auxiliar = [[0 for columna in range(self.size)] for fila in range(self.size)]
        for r in range(self.size):
            for c in range(self.size):
                clave = [key for key, value in self.diccionario_antiguo.items() if
                         value == self.matriz[r][c]]  # RETURN DE KEY A PARTIR DE VALOR
                asignar = clave[0]
                matriz_auxiliar[r][c] = asignar
        if inp == "I" or inp == "D":
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = str(matriz_auxiliar[r][c])
                    list1 = list1.replace(".", " ")
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = Matriz.encontrar(self, str1, "*")
                Matriz.movimiento(self, self.matriz, self.size, inp, str1, lugar, r, c)

        else:
            for r in range(self.size):
                lista = []
                for c in range(self.size):
                    list1 = str(matriz_auxiliar[c][r])
                    list1 = list1.replace(".", " ")
                    lista.append(list1)
                str1 = ''.join(lista)
                lugar = Matriz.encontrar(self, str1, "*")
                Matriz.movimiento(self, self.matriz, self.size, inp, str1, lugar, r, c)


    def encontrar(self, entrada, busqueda):
        """
         Este metodo nos permitira guardar en una lista las posiciones donde tenemos un "*"
         Parametros de entrada:cadena donde buscar,parametro a buscar
         Parametros de salida: lista que indica el/los lugares(fila o columna) del "*"
        """
        l1 = []
        length = len(entrada)
        index = 0
        while index < length:
            i = entrada.find(busqueda, index)
            if i == -1:
                return l1
            l1.append(i)
            index = i + 1
        return l1

    def movimiento(self, matriz, size, inp, str1, lugar, r, c, ):
        """
         Este metodo nos permitira trabajar con el string y moldearle como nosotros queremos. Primero analizamos según el tipo
         de movimiento y posteriormente si hemos detectado algun * que se encontraran en lugar.Si no detectamos ninguno, quitamos
         los espacios en blanco, llamamos a la funcion que realiza el movimiento y la fusion y posteriormente volvemos a quitar
         los espacios en blanco y llamamos a nueva matriz que nos genera la matriz resultante. Si hay algun * debemos hacer un paso
         previo de comprobacion si en a hay algun "" que nos indicaria que ha habido dos asteriscos juntos y creamos en este caso
         otro contador que nos indicarian las cadenas que en realidad contienen datos
         Parametros de entrada:matriz, tamano matriz, orden de movimiento,diccionario actual,cadena recibida, lista del lugar
         de los "*" ,contadores de filas y columnas de recorrer la matriz y el diccionario nivel que lo utilizaremos para los puntos.
         Salida: descarga en la funcion nueva_matriz el control que nos proporciona la matriz resultante.
        """
        if inp == "S" or inp == "I":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = Matriz.arriba_y_izquierda(self, cadena)
                fincad = nuevacad.replace(" ", "")
                Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = Matriz.arriba_y_izquierda(self, cadena)
                        fincad = nuevacad.replace(" ", "")
                        Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, i, cont)
                        cont = cont + 1
                    i = i + 1

        elif inp == "B" or inp == "D":
            if len(lugar) == 0:
                cadena = str1.replace(" ", "")
                nuevacad = Matriz.abajo_y_derecha(self, cadena)
                fincad = nuevacad.replace(" ", "")
                Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, c, 0)
            else:
                a = str1.split("*")
                i = 0
                cont = 0
                while i < len(a):
                    if a[i] != "":
                        cadena = a[i].replace(" ", "")
                        nuevacad = Matriz.abajo_y_derecha(self, cadena)
                        fincad = nuevacad.replace(" ", "")
                        Matriz.nueva_matriz(self, self.matriz, self.size, lugar, fincad, inp, r, i, cont)
                        cont = cont + 1
                    i = i + 1


    def abajo_y_derecha(self, cadrecibida):
        """
         En este metodo pasamos a una lista la cadena recibida para poder recorrerla y mutarla. Esta al ser la estructura de abajo y derecha
         lo que hacemos es recorrerla de atras hacia delante y miramos si los valores del puntero y el anterior son iguales para
         proceder a su fusion. Si esto sucede mediante el diccionario de nivel accedemos al valor de lo que vale la letra(ya que hemos convertido
         el diccionario actual al diccionario abc para poder trabajar el movimiento) y con esto sumamos los puntos y conseguidos que la fusion
         se lleve acabo.Por ultimo juntamos en un string toda la lista.
         Parametros de entrada:el string sin espacios y el diccionario de nivel.
         Salida: retorna el string ya fusionado.
        """

        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        if len(cadlista) != 1:
            while puntero > 0:
                if cadlista[puntero] == cadlista[puntero - 1]:
                    cadlista[puntero - 1] = " "
                    nueva = diccionario_fusión[cadlista[puntero]]
                    cadlista[puntero] = str(nueva)
                    pun_ganados = int(diccionario_puntos[nueva])
                    self.puntos = self.puntos + pun_ganados
                    puntos_str = str("PUNTOS: " + str(self.puntos))
                    self.label_puntos.SetLabelText(puntos_str)

                puntero = puntero - 1

        cadena = ''.join(cadlista)
        return cadena


    def arriba_y_izquierda(self, cadrecibida):

        # Mismo procedimiento ya comentado en la funcion abajo y derecha. Solo que en este caso empezamos a analizar la
        # cadena de alante hacia atras hasta la longitud maxima de la cadena.

        cadlista = list(cadrecibida)
        puntero = len(cadlista) - 1
        i = 0
        while i < puntero:
            if cadlista[i] == cadlista[i + 1]:
                cadlista[i + 1] = " "
                nueva = diccionario_fusión[cadlista[i]]
                cadlista[i] = str(nueva)
                pun_ganados = int(diccionario_puntos[nueva])
                self.puntos = self.puntos + pun_ganados
                puntos_str = str("PUNTOS: " + str(self.puntos))
                self.label_puntos.SetLabelText(puntos_str)

            i = i + 1

        cadena = ''.join(cadlista)
        return cadena


    def nueva_matriz(self, matriz, size, lugar, fincad, inp, pos, cont, bucle):
        """
         En este proceso lo que realizamos es según el movimiento indicado, introducir los valores que formaran la nueva matriz.
         Lo primero que haremos será limpiar la matriz y llenar los huecos que tenian asteriscos haciendo caso del lugar donde estaban.
         Lo siguiente sera introducir las cadenas. Para ello distinguimos si es sin asteriscos o con ellos, ya que en el primer caso
         no debemos tener "cuidado" de las posiciones iniciales de las cadenas. En cuanto al segundo caso mediante desarollamos un algoritmo
         mediante el cual comprueba si se trata de la primera cadena u otra. Si es la primera empezamos a introducir los valores de esta justo
         tras los asteriscos pertinentes( para lo cual desarrollamos un contador para saber la poscion exacta donde empezar).Sino se trata de
         la primera cadena con otro contador de nuevo contamos desde la ultima posicion del asterisco correspondiente al indice que traemos
         por entrada. Y posteriormente esa cadeana la introducimos a partir de ese indica mas el contador.
         Parametros de entrada:la matriz,su tamano,lista con el lugar de los *,diccionario actual, la columna o fila donde se deben introducir,
        """
        if inp == "S":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[i][pos] = self.diccionario_antiguo[fincad[i]]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[0 + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[contador + i][pos] = self.diccionario_antiguo[fincad[i]]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + i][pos] = self.diccionario_antiguo[fincad[i]]

        elif inp == "B":
            if bucle == 0:
                for r in range(size):
                    matriz[r][pos] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[lugar[r]][pos] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    self.matriz[self.size - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[0 + contador][pos] == self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[contador + j][pos] != self.diccionario_antiguo[
                            "*"]:
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[contador + j - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[0 + contador][pos] != self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[contador - 1 - i][pos] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                else:
                    contador = 0
                    while matriz[lugar[cont - 1] + contador][pos] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[lugar[cont - 1] + contador + j][
                        pos] != self.diccionario_antiguo["*"]:
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[lugar[cont - 1] + contador + j - 1 - i][pos] = self.diccionario_antiguo[
                            fincad[len(fincad) - 1 - i]]


        elif inp == "I":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][i] = self.diccionario_antiguo[fincad[i]]
            else:
                if bucle == 0:
                    contador = 0
                    while matriz[pos][0 + contador] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][contador + i] = self.diccionario_antiguo[fincad[i]]
                else:
                    contador = 0
                    while (lugar[cont - 1] + contador) <= (size - 1) and matriz[pos][lugar[cont - 1] + contador] == \
                            self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + i] = self.diccionario_antiguo[fincad[i]]

        elif inp == "D":
            if bucle == 0:
                for r in range(size):
                    matriz[pos][r] = self.diccionario_antiguo["."]
            for r in range(len(lugar)):
                matriz[pos][lugar[r]] = self.diccionario_antiguo["*"]
            if len(lugar) == 0:
                for i in range(len(fincad)):
                    matriz[pos][size - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
            else:
                if bucle == 0:
                    if lugar[0] == 0:
                        contador = 0
                        while matriz[pos][0 + contador] == self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        j = 0
                        while (contador + j) <= (size - 1) and matriz[pos][contador + j] != self.diccionario_antiguo[
                            "*"]:
                            j = j + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador + j - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                    else:
                        contador = 0
                        while contador <= (size - 1) and matriz[pos][0 + contador] != self.diccionario_antiguo["*"]:
                            contador = contador + 1
                        for i in range(len(fincad)):
                            matriz[pos][contador - 1 - i] = self.diccionario_antiguo[fincad[len(fincad) - 1 - i]]
                else:
                    contador = 0
                    while matriz[pos][lugar[cont - 1] + contador] == self.diccionario_antiguo["*"]:
                        contador = contador + 1
                    j = 0
                    while (lugar[cont - 1] + contador + j) <= (size - 1) and matriz[pos][
                        lugar[cont - 1] + contador + j] != self.diccionario_antiguo["*"]:
                        j = j + 1
                    for i in range(len(fincad)):
                        matriz[pos][lugar[cont - 1] + contador + j - 1 - i] = self.diccionario_antiguo[
                            fincad[len(fincad) - 1 - i]]


    def comparar(self, matriz, matriz_comparar, size):
        """
         Esta funcion lo que hace es comparar si las dos matrices de entrada: la que teniamos comparada con la actualizada tras el movimiento
         Si son iguales en todos los elementos devuelve True, sino False.
         Precondicion: Las dos matrices tienen el mismo tamano
         Parametros de entrada:la matriz antigua y la actual y su tamaño
         Salida: boolean que nos indicara si todos sus elementos son iguales

        """

        iguales = True
        for r in range(size):
            for c in range(size):
                if (matriz[r][c] != matriz_comparar[r][c]):
                    iguales = False

        return iguales



class MyApp(wx.App, DialogoInstrucciones):

    def OnInit(self):
        self.frame_20148 = MiVentana(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame_20148)
        self.frame_20148.Show()
        check = open("archextra/check.txt", "r+")
        self.check = check.readline()
        if self.check != "True":
            DialogoInstrucciones().ShowModal()
            DialogoInstrucciones().Destroy()
        check.close()

        return True


# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()

